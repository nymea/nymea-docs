---
id: interfaces
title: Interfaces
---

The main purpose of interfaces is to provide for a better user experience. Using interfaces, a plugin developer can suggest 
that the UI (User Interface) be used for this [ThingClass](/documentation/developers/integrations/thing-class#interfaces). For example, having a plugin that can control a dimmable light would likely have a 
state named "powered" of type _boolean_ and one named "brightness" of type _int_, ranging from 0 to 100%. Having just this 
information, the UI would create a generic switch component to flip the bool state and a generic slider component to 
allow adjusting the brightness because it can't know what the actual switch or slider do. For a better user experience though, 
the plugin developer could just add the interface "dimmedlight" to this deviceclass and this way tell the UI that this actually 
is a dimmed light. The ui can use this information to paint a pretty brightness slider, and implicitly flip the power switch off 
when the brightness slider is moved to the lowermost position.

Another purpose of interfaces is to help the UI with the task of grouping and managing things. For example the gateway interface does 
not require implementing any properties, however, it tells the UI that this is a gateway and thus making it no longer relevant to display to the 
user in the main control entity. Instead, gateways might be more appropriately listed in the configuration section of the client application.

In general it is a good idea to follow as many interfaces as precisely as possible in order to provide for the best user experience.

An interface can extend another interface. For example, the light interface only requires one state called _powered off type bool_. 
A dimmablelight extends this type and adds a brightness property to it. This means, if a ThingClass implements dimmablelight, 
it also needs to cater to light interface's states.

This is the list of interfaces available in nymea:


@@GENERATED_INTERFACES@@
